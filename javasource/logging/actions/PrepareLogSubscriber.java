// This file was generated by Mendix Studio Pro.
//
// WARNING: Only the following code will be retained when actions are regenerated:
// - the import list
// - the code between BEGIN USER CODE and END USER CODE
// - the code between BEGIN EXTRA CODE and END EXTRA CODE
// Other code you write will be lost the next time you deploy the project.
// Special characters, e.g., é, ö, à, etc. are supported in comments.

package logging.actions;

import java.util.HashMap;
import java.util.Map.Entry;
import com.mendix.core.Core;
import com.mendix.core.CoreException;
import com.mendix.logging.ILogNode;
import com.mendix.logging.LogLevel;
import com.mendix.logging.LogMessage;
import com.mendix.logging.LogSubscriber;
import com.mendix.systemwideinterfaces.core.IContext;
import com.mendix.systemwideinterfaces.core.IMendixObject;
import com.mendix.systemwideinterfaces.core.meta.IMetaObject;
import com.mendix.webui.CustomJavaAction;

/**
 * This action starts or stops the log subscriber. By passing the entity name and a boolean (start=true, stop=false), the action will either start listening or shut down.
 * 
 * If you start the log subscriber you must also stop it in the before shutdown, otherwise the shutdown event could take several minutes.
 * 
 * ------------------------------------------------------
 * @LogEntityName: The log entity should be the full entity name of where you want to store the messages. This entity must have an attribute called 'Message'. 
 * @StartSubscriber: True = Start, False = Stop
 * 
 * When choosing for logging multiple LogTypes, you can have an optional LogType attribute.
 * And in addition you are free to use additional fields with default values, such as a created date. 
 */
public class PrepareLogSubscriber extends CustomJavaAction<java.lang.Boolean>
{
	private java.lang.String LogEntityName;
	private java.lang.Boolean StartSubscriber;

	public PrepareLogSubscriber(IContext context, java.lang.String LogEntityName, java.lang.Boolean StartSubscriber)
	{
		super(context);
		this.LogEntityName = LogEntityName;
		this.StartSubscriber = StartSubscriber;
	}

	@java.lang.Override
	public java.lang.Boolean executeAction() throws Exception
	{
		// BEGIN USER CODE

		if( this.StartSubscriber )
			Core.registerLogSubscriber(LogProcessor.getInstance(this.LogEntityName));
		else 
			LogProcessor.getInstance(this.LogEntityName).stop();

		LogProcessor.getInstance(this.LogEntityName).subscribe(Core.getLogger("WebServices"), LogLevel.TRACE);
		
		return true;
		// END USER CODE
	}

	/**
	 * Returns a string representation of this action
	 * @return a string representation of this action
	 */
	@java.lang.Override
	public java.lang.String toString()
	{
		return "PrepareLogSubscriber";
	}

	// BEGIN EXTRA CODE

	public static class LogProcessor extends LogSubscriber {

		private boolean stopped = false;
		private IContext context = Core.createSystemContext();
		private static LogProcessor instance = null;
		private HashMap<String, LogType> supportedLognodes = new HashMap<String, LogType>();
		private final String entityName;

		public enum LogType {
			Webservice,
			//,Stocks
			//,Job
		}

		/**
		 * Creates a new {@link LogSubscriber} that logs to Mendix objects. Constructor is private to
		 * prevent external instantiation, use {@link #getInstance()} instead.
		 * 
		 * @param logLevel only messages of this log level or higher are logged ('NONE' disables all
		 *        logging)
		 * @throws CoreException 
		 */
		private LogProcessor( String entityName ) throws CoreException
		{
			super("LogProcessor", LogLevel.INFO);
			this.entityName = entityName;
			this.supportedLognodes.put("WebServices", LogType.Webservice);
			//this.supportedLognodes.put("Stocks", LogType.Stocks);
			//this.supportedLognodes.put("Job", LogType.Job);
			
			
			IMetaObject objInfo = Core.getMetaObject(this.entityName);
			if( objInfo == null )
				throw new CoreException("Invalid configuration, no entity found with name: " + this.entityName );

			if( objInfo.getMetaPrimitive("Message") == null )
				throw new CoreException("Invalid configuration, The entity: " + this.entityName + " must have an attribute called: 'Message'");
			
			for( Entry<String, LogType> entry : this.supportedLognodes.entrySet() ) {
				this.subscribe(Core.getLogger(entry.getKey()), LogLevel.TRACE);
			}
		}


		/**
		 * Returns the singleton instance of this class. If you want to set the log level (default is
		 * 'INFO'), make sure to do this prior to the first call to this method, see {@link #setLogLevel(LogLevel)}.
		 * 
		 * @return {@link MendixObjectLogSubscriber} instance
		 * @throws CoreException 
		 */
		public static synchronized LogProcessor getInstance( String entityName ) throws CoreException
		{
			if ( LogProcessor.instance == null ) {
				LogProcessor.instance = new LogProcessor(entityName);
			}
			return LogProcessor.instance;
		}

		@Override
		public void processMessage( LogMessage message ) {
			if ( !this.stopped ) {
				String nodeName = message.node.name();
//				for( Entry<ILogNode, LogLevel> e : this.getSubscriptions().entrySet() ) {
//					System.out.println( "Lognode: " + e.getKey().name() + " level " + e.getValue() );
//				}
				
				if ( this.supportedLognodes.containsKey(nodeName) ) {
					LogType currentType = this.supportedLognodes.get(nodeName);
					try {
						boolean storeMessage = true;
						String messageTxt = (String) message.message;
						IMendixObject messageObject = Core.instantiate(this.context, this.entityName);

						// int refPosition;
						// List<IMendixObject> result;
						switch (currentType) {
						// case Stocks:
						// refPosition = messageTxt.indexOf("|");
						// result = Core.retrieveXPathQuery(this.context, "//"+StockItem.getType()+"[" +
						// StockItem.MemberNames.ReferenceNr + "="+ messageTxt.substring(0, refPosition) + "]");
						// if( result.size() > 0 ) {
						// messageObject.setValue(this.context, LogItem.MemberNames.LogItem_StockItem.toString(),
						// result.get(0).getId());
						// messageObject.setValue(this.context, LogItem.MemberNames.LogItem_KwikfitCentre.toString(),
						// result.get(0).getValue(context, StockItem.MemberNames.StockItem_KwikfitCentre.toString()) );
						// }
						// result.clear();
						//
						// messageTxt = messageTxt.substring(refPosition+1);
						// break;
						case Webservice:
							if ( !messageTxt.startsWith("Created soap envelope") && !messageTxt.startsWith("Response content for")
									&& !messageTxt.startsWith("Created soap body") && !messageTxt.startsWith("Response message received")
									&& !messageTxt.contains("Incoming web service request") )
								storeMessage = false;
							break;
						// case Voucher:
						// refPosition = messageTxt.indexOf("|");
						// result = Core.retrieveXPathQuery(this.context, "//"+masterdata.proxies.Voucher.getType()+"["
						// + masterdata.proxies.Voucher.MemberNames.InternalReferenceNr + "="+ messageTxt.substring(0,
						// refPosition) + "]");
						// if( result.size() > 0 )
						// messageObject.setValue(this.context, LogItem.MemberNames.LogItem_Voucher.toString(),
						// result.get(0).getId());
						// result.clear();
						//
						// messageTxt = messageTxt.substring(refPosition+1);
						// break;
						// case Job:
						// refPosition = messageTxt.indexOf("|");
						// String[] values = messageTxt.substring(0, refPosition).split("/");
						//
						// result = Core.retrieveXPathQuery(this.context, "//"+job.proxies.Job.getType()+"[" +
						// job.proxies.Job.MemberNames.JobNr + "='"+ values[0] + "']");
						// if( result.size() > 0 )
						// messageObject.setValue(this.context, LogItem.MemberNames.LogItem_Job.toString(),
						// result.get(0).getId());
						// result.clear();
						// messageObject.setValue(this.context, LogItem.MemberNames.JobNr.toString(), values[0]);
						//
						// result = Core.retrieveXPathQuery(this.context,
						// "//"+centremanagement.proxies.KwikfitCentre.getType()+"[" +
						// centremanagement.proxies.KwikfitCentre.MemberNames.CentreNumber + "='"+ values[1] + "']");
						// if( result.size() > 0 )
						// messageObject.setValue(this.context, LogItem.MemberNames.LogItem_KwikfitCentre.toString(),
						// result.get(0).getId());
						// result.clear();
						//
						// messageTxt = messageTxt.substring(refPosition+1);
						// break;
						}

						if ( storeMessage ) {
							messageObject.setValue(this.context, "Message", messageTxt);
							if ( messageObject.hasMember("LogType") )
								messageObject.setValue(this.context, "LogType", currentType.toString());


							Core.commit(this.context, messageObject);
						}
						else
							Core.rollback(this.context, messageObject);
					}
					catch( final Exception ex1 ) {
						Core.getLogger(this.toString()).info("Could not create logitem, because of exception: ", ex1);
					}
				}
			}
		}


		/**
		 * Stops the logging to Mendix objects by this class.
		 */
		public void stop()
		{
			this.stopped = true;
		}
	}
	// END EXTRA CODE
}
