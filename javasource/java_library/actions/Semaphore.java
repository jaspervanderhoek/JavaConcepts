// This file was generated by Mendix Modeler.
//
// WARNING: Only the following code will be retained when actions are regenerated:
// - the import list
// - the code between BEGIN USER CODE and END USER CODE
// - the code between BEGIN EXTRA CODE and END EXTRA CODE
// Other code you write will be lost the next time you deploy the project.
// Special characters, e.g., é, ö, à, etc. are supported in comments.

package java_library.actions;

import java.util.HashMap;
import java.util.concurrent.TimeUnit;
import com.mendix.core.Core;
import com.mendix.systemwideinterfaces.core.UserAction;
import com.mendix.systemwideinterfaces.core.IContext;
import com.mendix.webui.CustomJavaAction;

/**
 * Based on the Identifier, only allow 1 process to run at the same time.
 * 
 * 
 * @Identifier,   Per identifier a separate Semaphore/lock will be created and used to track the locks
 * @LockTheProcess,  When true the action will attempt to aquire a lock, if false the Lock will be released
 * @TryUntilAvailable,   When true the action will keep on waiting for the lock to be released, and print a log message every 30 minutes.   If false, the action will wait for 10 minutes, after 10 minutes the java action will complete as well.
 * @ReferenceMessage,   free text field, will be included in the log messages for your reference.
 * 
 * @RETURN,  if the action returns TRUE, the lock has been aquired, if it returns FALSE another process was locking the resource.
 */
public class Semaphore extends CustomJavaAction<java.lang.Boolean>
{
	private java.lang.String Identifier;
	private java.lang.Boolean LockTheProcess;
	private java.lang.Boolean TryUntilAvailable;
	private java.lang.String ReferenceMessage;

	public Semaphore(IContext context, java.lang.String Identifier, java.lang.Boolean LockTheProcess, java.lang.Boolean TryUntilAvailable, java.lang.String ReferenceMessage)
	{
		super(context);
		this.Identifier = Identifier;
		this.LockTheProcess = LockTheProcess;
		this.TryUntilAvailable = TryUntilAvailable;
		this.ReferenceMessage = ReferenceMessage;
	}

	@Override
	public java.lang.Boolean executeAction() throws Exception
	{
		// BEGIN USER CODE
		try {

				if( this.LockTheProcess ) {
					java.util.concurrent.Semaphore semaphore;
					synchronized( Semaphore.semaphoreSet ) {
						if( !Semaphore.semaphoreSet.containsKey(this.Identifier) )
							Semaphore.semaphoreSet.put(this.Identifier, new java.util.concurrent.Semaphore(1));
						
						semaphore = Semaphore.semaphoreSet.get(this.Identifier);
					}
					
					do {
						int availablePermits = semaphore.availablePermits();
	
						if( availablePermits == 0  ) { 
							Core.getLogger(this.toString()).info("Unable to aquire a lock for identifier: " + this.Identifier + " / " + this.ReferenceMessage );
						}
						
						boolean lockAquired;
						if( this.TryUntilAvailable )
							lockAquired = semaphore.tryAcquire(30, TimeUnit.MINUTES);
						else
							lockAquired = semaphore.tryAcquire(10, TimeUnit.MINUTES);
						
						if( lockAquired )
							this.TryUntilAvailable = false;
						
						if( this.TryUntilAvailable )
							Core.getLogger(this.toString()).debug("Retrying to aquire a lock for identifier: " + this.Identifier + " / " + this.ReferenceMessage );
						else 
							return lockAquired;
						
					}
					while( this.TryUntilAvailable );
				}
				else {
					synchronized( Semaphore.semaphoreSet ) {
						if( Semaphore.semaphoreSet.containsKey(this.Identifier) )
							Semaphore.semaphoreSet.get(this.Identifier).release();
					}
				}
			
		}
		catch( InterruptedException e ) {
			Core.getLogger(this.toString()).error("An error occured while processing a semaphore for: " + this.Identifier + " to " + (this.LockTheProcess ? "lock" : "unlock") + " / " + this.ReferenceMessage );
		}
		
		return true;
		// END USER CODE
	}

	/**
	 * Returns a string representation of this action
	 */
	@Override
	public java.lang.String toString()
	{
		return "Semaphore";
	}

	// BEGIN EXTRA CODE
	
	private static HashMap<String, java.util.concurrent.Semaphore> semaphoreSet = new HashMap<String, java.util.concurrent.Semaphore>();
	// END EXTRA CODE
}
