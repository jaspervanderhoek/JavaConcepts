// This file was generated by Mendix Business Modeler.
//
// WARNING: Only the following code will be retained when actions are regenerated:
// - the import list
// - the code between BEGIN USER CODE and END USER CODE
// - the code between BEGIN EXTRA CODE and END EXTRA CODE
// Other code you write will be lost the next time you deploy the project.
// Special characters, e.g., é, ö, à, etc. are supported in comments.

package java_library.actions;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.InputStream;
import java.io.OutputStream;
import system.proxies.FileDocument;
import com.mendix.core.Core;
import com.mendix.core.CoreException;
import com.mendix.systemwideinterfaces.core.IContext;
import com.mendix.systemwideinterfaces.core.IMendixObject;
import com.mendix.webui.CustomJavaAction;

/**
 * 
 */
public class CopyFileDocumentToFilePath extends CustomJavaAction<Boolean>
{
	private IMendixObject FileDocumentToCopy;
	private String DestinationFolderName;
	private String DestinationFileName;
	private Boolean CreateFolderIfItDoesNotExists;
	private Boolean RenameFileIfFileExists;

	public CopyFileDocumentToFilePath(IContext context, IMendixObject FileDocumentToCopy, String DestinationFolderName, String DestinationFileName, Boolean CreateFolderIfItDoesNotExists, Boolean RenameFileIfFileExists)
	{
		super(context);
		this.FileDocumentToCopy = FileDocumentToCopy;
		this.DestinationFolderName = DestinationFolderName;
		this.DestinationFileName = DestinationFileName;
		this.CreateFolderIfItDoesNotExists = CreateFolderIfItDoesNotExists;
		this.RenameFileIfFileExists = RenameFileIfFileExists;
	}

	@Override
	public Boolean executeAction() throws Exception
	{
		// BEGIN USER CODE
		return CopyFileDocumentToFilePath.copyMendixObjectContentToFile(getContext(), this.DestinationFolderName, this.DestinationFileName, this.FileDocumentToCopy, this.CreateFolderIfItDoesNotExists, this.RenameFileIfFileExists);
		// END USER CODE
	}

	/**
	 * Returns a string representation of this action
	 */
	@Override
	public String toString()
	{
		return "CopyFileDocumentToFilePath";
	}

	// BEGIN EXTRA CODE

	/**
	 * Copy the content from the FileDocument object to a file at the given DestinationFolder. If
	 * the folder doesn't exists and the boolean FolderCanBeCreated is true a folder will try to be
	 * created. If either the boolean is false or the folder can't be created for i.e. security
	 * reasons an exception will be thrown. If the folder exists the file will be stored in the
	 * folder.
	 * 
	 * The DestinationFileName is an optional parameter. If the parameter is set, that file name
	 * will be used to store the file. If the parameter is 'empty' the file will be stored with the
	 * original file name. If there is already a File in that folder with the same name it can be
	 * renamed automatically if the AutoRenameFile boolean is set to true.
	 * 
	 * @param destinationFolder
	 *        , the folder where the new file will be stored
	 * @param destinationFileName
	 *        , (Optional) when not null, this will be the name of the file
	 * @param fileDocumentObject
	 *        , the mendix object from which the content will be used
	 * @param folderCanBeCreated
	 *        , (Optional) if true the destination folder can be created if it doesn't exists
	 * @param autoRenameFile
	 *        , (Optional) if true the file will be renamed if a file exists with the same name
	 * @throws CoreException
	 */
	private static boolean copyMendixObjectContentToFile(IContext context, String destinationFolder, String destinationFileName, IMendixObject fileDocumentObject, Boolean folderCanBeCreated, Boolean autoRenameFile) throws CoreException {
		/*
		 * Check if the given folder is not emty and check if the Filedocument is not empty
		 */
		if (fileDocumentObject == null) {
			Core.getLogger("FileManager").warn("No FileDocument provided, parameter was empty");
			throw new CoreException("No FileDocument instance provided");
		}
		if (((String) fileDocumentObject.getValue(context, FileDocument.MemberNames.Name.toString()))==null) {
			Core.getLogger("FileManager").warn("The provided FileDocument has no content, based on name validation");
			throw new CoreException("The provided FileDocument has no content");
		}
		if (!(Boolean) fileDocumentObject.getValue(context, FileDocument.MemberNames.HasContents.toString())) {
			Core.getLogger("FileManager").warn("The provided FileDocument has no content, based on HasContents boolean");
			throw new CoreException("The provided FileDocument has no content");
		}

			destinationFolder = checkFilePath(destinationFolder);

		// Get the fileName, check if the filename should be used from the parameter or from the
		// file object
		String fileName;
		if (destinationFileName != null && !"".equals(destinationFileName.trim()))
			fileName = destinationFileName;
		else
			fileName = fileDocumentObject.getValue(context, "Name");

		/*
		 * Check if the destination folder exists When the folder doesn't exist try to create a new
		 * folder if that is allowed
		 */
		File folder = new File(destinationFolder);
		boolean folderExists = true;
		if (!folder.exists()) {
			if (folderCanBeCreated != null && folderCanBeCreated) {
				if (!folder.mkdirs()) {
					folderExists = false;
				}
			}
			else
				folderExists = false;
		}

		if (!folderExists)
			throw new CoreException((folderCanBeCreated ? "No folder found and it could not be created either. The path was: " + destinationFolder : "No folder found. The path was: " + destinationFolder));

		File newFile = new File(destinationFolder + fileName);

		/*
		 * Check if the file exists if it does exists check if it can be renamed. If not throw an
		 * exception When a file can be renamed do this by adding a number between the extension and
		 * the filename example( original filename: documentName.doc will be renamed to
		 * documentName_2.doc ) or if there is no . in the filename the number will be added in
		 * front of the filename
		 */
		if ((autoRenameFile == null || autoRenameFile == false) && newFile.exists())
			throw new CoreException("A file with the name: " + fileName + " already exists and autorename was set to false, the folder is: " + destinationFolder);
		int nr = 0;
		while (newFile.exists())
			newFile = new File(destinationFolder + (fileName.lastIndexOf(".") > 0 ? (fileName.substring(0, fileName.lastIndexOf(".")) + "_" + (++nr) + fileName.substring(fileName.lastIndexOf("."))) : (++nr) + "_" + fileName));

		// Get the content from the filedocument
		InputStream ioStream = Core.getFileDocumentContent(context, fileDocumentObject);
		try {
			OutputStream out = new FileOutputStream(newFile);

			// Transfer bytes from in to out
			byte[] buf = new byte[1024];
			int len;
			while ((len = ioStream.read(buf)) > 0) {
				out.write(buf, 0, len);
			}
			ioStream.close();
			out.flush();
			out.close();
		}
		catch (Exception e) {
			throw new CoreException("The file could not be stored in the new location: " + destinationFolder + destinationFileName, e);
		}

		return true;
	}

	/**
	 * Try to find the specified location and store the file with the given name in the Contract
	 * from the parameter. If the file or the folder could not be found a exception will be thrown
	 * 
	 * @param context
	 *        , A Mendix context to check if the user is allowed to store the content
	 * @param sourceFilePath
	 *        , The location of the folder
	 * @param sourceFileName
	 *        , The name of the file that should be read
	 * @param destinationObject
	 *        , The MendixObject to store the file in
	 * @return boolean, true if the file is stored succesfull
	 * @throws CoreException
	 */
	@SuppressWarnings("unused")
	private static Boolean storeFileInMendixObject(IContext context, String sourceFilePath, String sourceFileName, IMendixObject destinationObject) throws CoreException {
		if (destinationObject == null)
			throw new CoreException("The object to store the file in is empty.");

		sourceFilePath = checkFilePath(sourceFilePath);

		if (sourceFileName == null || "".equals(sourceFileName.trim()))
			throw new CoreException("The parameter fileName was empty.");

		File f = new File(sourceFilePath + sourceFileName);

		/*
		 * Check if the file exists and if it can be read
		 */
		if (!f.exists())
			throw new CoreException("No file exists at location: " + sourceFilePath + sourceFileName);
		if (!f.canRead())
			throw new CoreException("The file could not be read, the location is: " + sourceFilePath + sourceFileName);

		// If the file exists try to store it in the given destination object
		try {
			FileInputStream storeStream = new FileInputStream(f);
			Core.storeFileDocumentContent(context, destinationObject, f.getName(), storeStream);
		}
		catch (FileNotFoundException e) {
			throw new CoreException("The file could not be stored because something went wrong while reading the file, the location was: " + sourceFilePath + sourceFileName, e);
		}

		return true;
	}

	@SuppressWarnings("unused")
	private static IMendixObject copyFileDocument(IContext context, IMendixObject sourceFileDocument) throws CoreException {
		IMendixObject targetFile = Core.instantiate(context, "System.FileDocument");
		copyFileDocument(context, sourceFileDocument, targetFile);
		return targetFile;
	}

	private static void copyFileDocument(IContext context, IMendixObject sourceFileDocument, IMendixObject targetFileDocument) {
		InputStream inStream = Core.getFileDocumentContent(context, sourceFileDocument);
		Core.storeFileDocumentContent(context, targetFileDocument, (String) sourceFileDocument.getValue(context, "Name"), inStream);
	}

	/**
	 * Check if the path is a usable path, the path must at least and with a slash
	 * 
	 * @param path
	 * @return the path, possibly with an extra slash at the end
	 * @throws CoreException
	 */
	private static String checkFilePath(String path) throws CoreException {
		if (path == null || "".equals(path.trim()))
			throw new CoreException("The Folder location is empty.");

		// It is possible that the folder does not end with a slash, if it doesn't at a closing
		// slash to the destination folder
		if (!path.endsWith("\\") && !path.endsWith("/"))
			path += "/";

		return path;
	}

	// END EXTRA CODE
}
